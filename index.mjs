import Inertia, { shouldIntercept } from 'inertia';
export { default as Inertia } from 'inertia';
import { SvelteComponent, init, safe_not_equal, empty, mount_component, insert, get_spread_update, group_outros, on_outro, check_outros, detach, subscribe, assign, create_slot, element, listen, get_slot_changes, get_slot_context } from 'svelte/internal';
import { createEventDispatcher, onDestroy } from 'svelte';
import { writable, derived } from 'svelte/store';

/* src/App.svelte generated by Svelte v3.4.4 */

function create_fragment(ctx) {
	var switch_instance_anchor, current;

	var switch_instance_spread_levels = [
		ctx.$page.props
	];

	var switch_value = ctx.$page.component;

	function switch_props(ctx) {
		let switch_instance_props = {};
		for (var i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}
		return { props: switch_instance_props };
	}

	if (switch_value) {
		var switch_instance = new switch_value(switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) switch_instance.$$.fragment.c();
			switch_instance_anchor = empty();
		},

		m(target, anchor) {
			if (switch_instance) {
				mount_component(switch_instance, target, anchor);
			}

			insert(target, switch_instance_anchor, anchor);
			current = true;
		},

		p(changed, ctx) {
			var switch_instance_changes = changed.$page ? get_spread_update(switch_instance_spread_levels, [
				ctx.$page.props
			]) : {};

			if (switch_value !== (switch_value = ctx.$page.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;
					on_outro(() => {
						old_component.$destroy();
					});
					old_component.$$.fragment.o(1);
					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props(ctx));

					switch_instance.$$.fragment.c();
					switch_instance.$$.fragment.i(1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}

			else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},

		i(local) {
			if (current) return;
			if (switch_instance) switch_instance.$$.fragment.i(local);

			current = true;
		},

		o(local) {
			if (switch_instance) switch_instance.$$.fragment.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(switch_instance_anchor);
			}

			if (switch_instance) switch_instance.$destroy(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $page;

	subscribe($$self, page, $$value => { $page = $$value; $$invalidate('$page', $page); });

	let { initialPage, resolveComponent, transformProps = i => i } = $$props;

  Inertia.init({
    initialPage,
    resolveComponent,
    updatePage: (component, props, { preserveState }) => {
      page.set({ component, props: transformProps(props) });
    },
  });

	$$self.$set = $$props => {
		if ('initialPage' in $$props) $$invalidate('initialPage', initialPage = $$props.initialPage);
		if ('resolveComponent' in $$props) $$invalidate('resolveComponent', resolveComponent = $$props.resolveComponent);
		if ('transformProps' in $$props) $$invalidate('transformProps', transformProps = $$props.transformProps);
	};

	return {
		initialPage,
		resolveComponent,
		transformProps,
		$page
	};
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, ["initialPage", "resolveComponent", "transformProps"]);
	}
}

/* src/Link.svelte generated by Svelte v3.4.4 */

function create_fragment$1(ctx) {
	var a, current, dispose;

	const default_slot_1 = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_1, ctx, null);

	return {
		c() {
			a = element("a");

			if (default_slot) default_slot.c();

			a.href = ctx.href;
			dispose = listen(a, "click", ctx.visit);
		},

		l(nodes) {
			if (default_slot) default_slot.l(a_nodes);
		},

		m(target, anchor) {
			insert(target, a, anchor);

			if (default_slot) {
				default_slot.m(a, null);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && changed.$$scope) {
				default_slot.p(get_slot_changes(default_slot_1, ctx, changed, null), get_slot_context(default_slot_1, ctx, null));
			}

			if (!current || changed.href) {
				a.href = ctx.href;
			}
		},

		i(local) {
			if (current) return;
			if (default_slot && default_slot.i) default_slot.i(local);
			current = true;
		},

		o(local) {
			if (default_slot && default_slot.o) default_slot.o(local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(a);
			}

			if (default_slot) default_slot.d(detaching);
			dispose();
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	

  const dispatch = createEventDispatcher();

  let { href, data = {}, method = 'get', replace = false, preserveScroll = false, preserveState = false } = $$props;

  function visit(event) {
    dispatch('click', event);

    if (shouldIntercept(event)) {
      event.preventDefault();

      Inertia.visit(href, {
        data,
        method,
        preserveScroll,
        preserveState,
        replace,
      });
    }
  }

	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$props => {
		if ('href' in $$props) $$invalidate('href', href = $$props.href);
		if ('data' in $$props) $$invalidate('data', data = $$props.data);
		if ('method' in $$props) $$invalidate('method', method = $$props.method);
		if ('replace' in $$props) $$invalidate('replace', replace = $$props.replace);
		if ('preserveScroll' in $$props) $$invalidate('preserveScroll', preserveScroll = $$props.preserveScroll);
		if ('preserveState' in $$props) $$invalidate('preserveState', preserveState = $$props.preserveState);
		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
	};

	return {
		href,
		data,
		method,
		replace,
		preserveScroll,
		preserveState,
		visit,
		$$slots,
		$$scope
	};
}

class Link extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["href", "data", "method", "replace", "preserveScroll", "preserveState"]);
	}
}

const page = writable({
  component: null,
  props: {},
});

const pageProps = derived(page, $page => $page.props);

function rememberedState(initialState, key) {
    const restored = Inertia.restore(key);
    const store = writable(restored || initialState);

    const unsubscribe = store.subscribe(state => Inertia.remember(state, key));

    onDestroy(() => {
        unsubscribe();
    });

    return store
}

export default App;
export { Link as InertiaLink, page, pageProps, rememberedState };
